title: 移动端滚动解决方案
date: 2016-12-03 22:22:22
permalink: phoneWeb
tags:
- 移动端
categories:
- 前端
---
一直以来都在做pc端的开发，主要的业务都是OA或ERP系统，但是俩者我也分不清楚哪些区别，对于这一年多的开发，主要是在处理业务逻辑与数据处理，由于公司技术岗位的特殊，所有的业务逻辑与数据处理都在前端来完成，后端只是纯粹的给与数据配合，而在前端特效与网络http协议方面的东西涉及的比较少，但是丝毫没有阻止自己前进的步伐，一直在关注移动端的发展，并且跟进移动开发的技术。今天在做自己的业余项目的时候遇到了下拉刷新、移动端滚动流畅的问题
## 关注移动端
{% blockquote %}
今年(2016)天猫双十一80%+的移动端成交量说明了一切，前端的未来在于移动端，erp或者oa系统的发展也开始走向web，但是未来纯前端er在系统开发方面会有天花板，如果具备牛逼的后端数据处理与服务器维护开发兼前端，职业也是很明朗的
{% endblockquote %}
<!-- more -->
{% img /images/scroll.png 746 413 滚动下拉刷新与无限滚动 %}
## 关于滚动
### 在以前滚动的需求，一般有二种解决方案，
#### 一是通过浏览器自带滚动条
通过设置父元素固定宽度，然后给与overflow:auto/overflow:scroll;
auto与scroll的区别是，前者在溢出的时候才会出现滚动条，后者是在一开始的时候就出现滚动条。
webkit内核的浏览器可以通过css来自定义滚动条的形状，可以设定宽、背景颜色、滚动条头尾的形状
{% codeblock %}
	/*自定义滚动条*/
	::-webkit-scrollbar-track-piece{ 
	        background-color:#fff; 
	        -webkit-border-radius:0; 
	} 
	::-webkit-scrollbar{ 
	        width:0px; 
	        height:0px;
	} 
	::-webkit-scrollbar-thumb{ 
	        height:0px; 
	        background-color:#e0e0e0; 
	        -webkit-border-radius:20px; 
	        outline:2px solid #fff;
	        outline-offset:-2px;
	        border: 2px solid #fff; 
	        opacity: 0.5;
	        filter: alpha(opacity=50);
	} 
	::-webkit-scrollbar-thumb:hover{ 
	        height:50px; 
	        background-color:#9f9f9f; 
	        -webkit-border-radius:20px; 
	}
{% endcodeblock %}
#### 二是通过js模拟
最初接触前端的时候还用原生js模拟过自定义滚动条({% link 原生js模拟滚动条 http://www.chongblog.com/gd true 原生js模拟滚动条 %})，主要的思想就是通过设置position为absoult，来设置top值。其实这在移动端的原理也是差不了多少，移动端的思想css3的translate3d 属性来模拟，通过js获取鼠标(mousedown,mousemove,mouseup)或者触摸(touchstart,touchmove,touchend)获取滑动的距离来设置3d移动值，以下是在之前未用isscroll.js的时候自己写的一段代码，滑动与下拉刷新
{% codeblock %}
 (function(){
 // 容器(父元素)
 var content = $('.content');
 // 内容元素
 var index = $('.indexPage');
 var point = {};
 // // 记录鼠标开始位置 x ，y
 // var point={};
 point.translate3dY=0;
 var contentHeight,wrapHeight,maxTransform;
 // 内容的高度
 contentHeight = _getCurrentStyle(content,'height');
 
 wrapHeight = _getCurrentStyle(index,'height');
 
 maxTransform = parseInt(contentHeight) - parseInt(wrapHeight)+150;
 
 // 开始触摸
 ev.addEvent(content,'touchstart',function(event){
 		event.stopPropagation();
 		point.y = ev.getPoint(event).y;
 });
 // 触摸滑动
 ev.addEvent(content,'touchmove',function(event){
  event.stopPropagation();
  // 下拉刷新 
  if(index.scrollTop<=0){
   // 移动的距离
   point.s =  ev.getPoint(event).y - point.y;
   if(point.s>0){
   	point.y = ev.getPoint(event).y;
   	point.translate3dY += point.s;
   }
 
   if(point.translate3dY>0 && point.translate3dY<100){
    $('.reload').style.display = 'block';
    $('.reload').style.height = point.translate3dY+'px';
    $('.reload').style.lineHeight =  point.translate3dY + 'px';
    if(point.translate3dY>80){
    	$('.reload').style.background = "url(./lib/icons/reloading.png)";
    	$('.reload').style.backgroundRepeat = "no-repeat";
    	$('.reload').style.backgroundPosition= "50% 50%";
    	$('.reload').style.backgroundSize = "1rem";
    }
    	 _setTransform(this,point.translate3dY);
   }
  }else{
  	point.translate3dY = 0;
  }
  	
 });
 // 移动释放
 ev.addEvent(content,'touchend',function(event){
  if(point.translate3dY>0){
   _setTransform(this,0);
   point.translate3dY = 0;
   $('.reload').style.background = "url(./lib/icons/downreloading.png)";
   $('.reload').style.backgroundRepeat = "no-repeat";
   $('.reload').style.backgroundPosition= "50% 50%";
   $('.reload').style.backgroundSize = "1rem";
   $('.reload').style.display = 'none';
   $('.reload').style.height = 0+'px';
   $('.reload').style.lineHeight =  0 + 'px';
  }
 });
 
 // 回到顶部操作
 ev.addEvent($('.backTop'),'click',function(){
 	
  index.scrollTop = 0;
 
 });
 // 回到顶部按钮元素
 ev.addEvent(index,'scroll',function(event){
 
  point.scrollTop=this.scrollTop;	
 
  _srolltop(point);
 });
 // 回到顶部显示
 function _srolltop(_point){
  var dom = $('.backTop');
 
  if(_point.scrollTop>200){
   dom.style.zIndex = 2;
   dom.style.opacity = 1;
 
  }else{
   dom.style.zIndex = -5;
   dom.style.opacity = 0;
  }
 }
 
 // 工具函数
 // 获取样式
 function _getCurrentStyle(obj,attr){
  return obj.currentStyle?obj.currentStyle[attr]:getComputedStyle(obj)[attr];
 }
 // 获取元素
 function $(dom){
 
 	return document.querySelector(dom);
 
 }
 // 设置元素属性
 function _setTransform(dom,val){
 
 	dom.style.webkitTransform = 'translate3d(0px,'+(val)+'px,0px)';
 	dom.style.mozTransform = 'translate3d(0px,'+(val)+'px,0px)';
 	dom.style.msTransform = 'translate3d(0px,'+(val)+'px,0px)';
 	dom.style.oTransform = 'translate3d(0px,'+(val)+'px,0px)';
 	dom.style.transform = 'translate3d(0px,'+(val)+'px,0px)';
 
 }
 // 事件绑定	
 var method = (function(){
   function _getDom(dom){
   	return document.querySelector(dom);
   }
   var addClass=function(doms,classnames){
   	var clsName = _getDom(doms).className;
   	clsName +=' '+classnames;
   	_getDom(doms).className = clsName;
   };
   var removeClass=function(doms){
   	var clsName = document.querySelector(doms).className;
   	var clsNameAry = clsName.split(' ');
   			clsNameAry.pop();
   	document.querySelector(doms).className = clsNameAry.join(' ');
   };
   return {
   	addClass:addClass,
   	removeClass:removeClass
   };
 })();
 })();
{% endcodeblock %}
以上有一个最大的缺点就是滑动不流畅，要想达到流畅，需要通过一定的算法来实现
在touchmove到touchend移动的距离与时间的关系来判断用户移动的快慢，进而控制translate的变化过度时间(transition);
### 移动端解决方案
移动端的原生解决方案
weibit内核浏览器有个原生的区域滚动方案很好的解决了流畅性的问题
{% codeblock %}
	body{overflow: scroll; -webkit-overflow-scrolling: touch;}
{% endcodeblock %}
isscrolljs 解决方案
移动端最多的就是用isscroll解决的，该滚动库很好的解决了所有的问题，包括水平垂直滚动，啦下刷新/无限下拉刷新等需求都封装的很好。实用angularjs还要对该库进行封装成指令。










