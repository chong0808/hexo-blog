title: 项目的坑——深复制(对象的引用传递)
date: 2016-12-08 22:44:12
permalink: top_pro
tags:
- 同速项目
- js基础
categories:
- 前端

---
这个项目11月底刚开始，静态页面花了俩天搞好，最近一直在调数据，由于客户端与服务端的通信较不同寻常，所以调数据一直是一个比较麻烦的过程，每个项目从启动到能上线，起码要经过三次大的调试，第一次是自己前端开发交互式模拟一些数据进行开发出交互效果，这次数据是完全自己预定的，第二次是通过第一次的数据需求，通知后台前台需要什么数据，进行协调确定数据格式，这是苦逼的第二次，因为要配合后台给的数据(这次数据往往与前面一次千差万别)把逻辑走通，最后一次是上线的联调。
程序员的修炼就是不断的踩坑的过程。
<!-- more -->
### 项目需求
添加新建的项目，然后把新增项目加进项目列表
 {% img /images/120801.png 1280 730 %}
选择添加收费项目与选择添加的数量
 {% img /images/120803.png 1280 730  %}
确定之后加入列表，最关键的是在这里，要根据数量，将之前选的项目进行复制出5份，在这个过程中，要将数据进行处理，
 {% img /images/120804.png 1280 730 %}
从点击确定到跳转回项目列表这个过程中，有个事件进行广播，将要添加的数据进行传递到当前作用域，在传递到当前作用域广播数据的时候进行数据处理,每个项目由N个数量就要将其进行复制出N个病程，然后 每个病程都是独立的，可对其进行步骤的选择
一开始我都是直接对其进行push进缓存数组中，结构出现了在每个病程点击步骤选择的时候，同项目的其他病程都会联动反应。
这里这里忽略了一个叫做对象引用传递的东西，找出结果，独立封装出一个extend()方法的复制功能函数，见代码。
{% codeblock %}
//点击确定进行数据广播且进行数据处理
$scope.selectPro = function () {
 var obj=[];
 if($scope.slectItems.length>0){
  for(let i=0;i<$scope.slectItems.length;i++){
   var row =[];
   for(let j=0;j<$scope.slectItems[i].number;j++){
   	//row.push($scope.slectItems[i]))//直接对其进行push进row中,导致后面引用的时候出现对象引用错误
   	row.push(query.extend($scope.slectItems[i]))
   }
   delete $scope.slectItems[i].number;
   obj.push(row)
   row.length = 0; //清空缓存
  }

  $rootScope.$emit($stateParams.id,obj);
  $scope.goBack();
 }
}
.factory('query',function () {
 //深复制工具函数
 function _query(obj1,obj2,arr,str) {
  if(typeof obj1 =='object' && typeof obj2 =='object'){
   if(obj1[str]==obj2[str]){
   	arr.push(obj1);                         
   }
  }
 	return arr;
 }
 return{
 	extend:_extend
 }
})
{% endcodeblock %}
### 关于引用传递
javaScript的7种数据类型种分，分原始类型与对象类型
#### 1.原始类型
原始类型有number,string,布尔值,null,undefind
原始数据类型是按值传递的，也就是说在原来的值传递给后面的值之后，后面的值改变了也不影响原来值得改变
{% codeblock %}
var a='abc';
var b=a;
a='ABC';
console.log(b)//输出 abc a的改变不影响b的值
{% endcodeblock %}
#### 2.对象类型
在js中任何东西都是一个对象，对象是属性的集合，每个属性都是名/值对构成的，对象都是按引用进行传递的，这在底层的C中所说的指针的意思
{%  codeblock %}
var obj_a={
		a:'abc'
};
var obj_b=obj_a;
obj_a.a='ABC';
console.log(obj_b)//输出 ABC a的改变影响b的值
{%  endcodeblock %}
这里的obj_a与obj_b是一种对象指向的关系，就是说obj_a的值是指向一个a=abc的地址符号，obj_b=obj_a是将这个地址符号传递给obj_b，并不是讲值传递给obj_b，他们之间共同指向的还是痛一个值，只要一个值得改变立马引起另一个值得改变，
{%  codeblock %}
obj_b.a ='123';
console.log(obj_a) //输出123
{%  endcodeblock %}
本质上在&obj_a == &obj_b的他们的地址符都指向相同的一个地方
#### 诡异小心的地方
obj_a与obj_b 是俩个不想同的东西
{%  codeblock %}
console.log(obj_a === obj_b) //输出的是false
{%  endcodeblock %}
在js中任何的俩个对象都是不相等的。

### 深复制
那么在对象要进行复制传递的时候怎么做的？
因为js中的对象有三个属性
1.可写，表明是否可以设置该属性的值
2.可枚举，表明是否可通过for in 来循环返回属性
3.可配置，表明是否可以删除或修改该属性
那么任何属性都是具有可枚举性，可通过for in来循环，但是js中规定，只有自己拥有的属性才能通过for in 进行循环遍历，通过原型链上继承的属性是不能遍历的，这的意识是比如每个js中每个对象都有个toString()跟valueOf方法，但是该属性是通过继承Object而来的，所以在遍历的时候这俩个方法是遍历不出来的。
{%  codeblock %}
var obj_a={
	a:'A',
	b:'B',
	c:'C'
}
var obj_b;
for(key in obj_a){
	console.log(key) // 输出 A B C 
	obj[key]=obj_a[key];
}
console.log(obj_b.a) // 输出 A
obj_a.a ='123';
console.log(obj_b.a) //输出 A
obj_b.a='AA';
console.log(obj_a.a) //输出 123
{%  endcodeblock %}
#### 按值传递的复制
在下面中是项目在接收到广播的数据进行数据处理的时候·讲data的值复制到$scope.proCost这个对象当中，那么下面的代码为什么不用for in 循环
{%  codeblock %}
// 接收数据，再对数据进行处理
$rootScope.$on('hj',function (e,data) {
 if(Array.isArray(data)){
  for(let i=0;i<data.length;i++){
   var obj = {};
   obj.name=data[0][0].name;
   obj.number =data[i].length;
   obj.dw = data[0][0].dw;;
   obj.price=data[0][0].price;
   obj.proNum=data[0][0].proNum;
   obj.row =[];
   obj.discount = data[0][0].discount;
   obj.rowNum =$scope.topRow+1+i
   obj.totalPrice=Number(0);
   obj.operNum=$rootScope.currentDoctorNum;
   obj.row.push(data[i])
   for(let j=0;j<data[i].length;j++){
   	obj.totalPrice += Number(data[i][j].price)
   	data[i][j].currcase='方案'
   }
   $scope.proCost.push(obj);
  }
  console.log($scope.proCost)
  $scope.topRow=$scope.proCost.length;
 }
})
{% endcodeblock %}
不是所有的对象的复制都是需要用for in来循环遍历的，在上面的代码中都是通过for循环来取得data里面的值，取到的值都是string类型的值了。直接赋值到obj对象上，是发生按值传递了，
其实要明白for in的本质也是取得每个对象的string值然后将按值传递赋值给另一个对象。



